/**********************************************************************************
BSD 3-Clause License

Copyright (c) 2021, Orso Eric
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**********************************************************************************/

/**********************************************************************************
**  ENVIROMENT VARIABILE
**********************************************************************************/

#ifndef CLASS_PID_S32_HPP_
    #define CLASS_PID_S32_HPP_

/**********************************************************************************
**  GLOBAL INCLUDES
**********************************************************************************/

#include <stdint.h>
#include <cmath>
#include "at_utils.h"
//Error Handler class. handling of errors and warning
#include "error_handler.hpp"

/**********************************************************************************
**  DEFINES
**********************************************************************************/

//Enable the file trace debugger
//#define ENABLE_DEBUG
//file trace debugger
#ifdef ENABLE_DEBUG
    #include <cstdio>
    #include "debug.h"
#endif
//If DEBUG is not needed, blank out the implementations
#ifndef DEBUG_H_
    #define DEBUG_VARS_PROTOTYPES()
    #define DEBUG_VARS()
    #define DSHOW( ... )
    #define DSTART( ... )
    #define DSTOP()
    #define DTAB( ... )
    #define DPRINT( ... )
    #define DPRINT_NOTAB( ... )
    #define DENTER( ... )
    #define DRETURN( ... )
    #define DENTER_ARG( ... )
    #define DRETURN_ARG( ... )
#endif

/**********************************************************************************
**  MACROS
**********************************************************************************/

/**********************************************************************************
**  NAMESPACE
**********************************************************************************/

//! @namespace custom namespace
namespace Orangebot
{

/**********************************************************************************
**  TYPEDEFS
**********************************************************************************/

/**********************************************************************************
**  PROTOTYPE: STRUCTURES
**********************************************************************************/

/**********************************************************************************
**  PROTOTYPE: GLOBAL VARIABILES
**********************************************************************************/

/**********************************************************************************
**  PROTOTYPE: CLASS
**********************************************************************************/

/************************************************************************************/
//! @class      Pid_s32
/************************************************************************************/
//!	@author     Orso Eric
//! @version    2021-03
//! @brief      xxx
//! @copyright  BSD 3-Clause License Copyright (c) 2020, Orso Eric
//! @details
//! \n	Inherit the Error_handler class to handle warning and error reference to constant string fast
//! \n	NOTE: public inheritance maps public->public and protected->protected
//! \n		2021-03-
//! \n	Initial Release
//! \n		2021-04-03
//! \n	closed KP loop with example
/************************************************************************************/

class Pid_s32 : public User::Error_handler
{
    //Visible to all
    public:
        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC ENUMS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //! @brief Configurations of the class
        enum Config
        {
        	//Any fixed point position above this setting is forbidden
			PID_FIXED_POINT_LIMIT = 30,
        	//Checks active
            SAFETY_CHECK = true,
            PEDANTIC_CHECKS = true,
        };

        //! @brief Enumerate possible PID gains
        enum Index
        {
        	//Index of PID gains
			PID_GAIN_KP = 0,
			PID_GAIN_KI = 1,
			PID_GAIN_KD = 2,
			PID_NUM_GAINS = 3,
			PID_CMD_LIMIT_MIN = 0,
			PID_CMD_LIMIT_MAX = 1,
			PID_NUM_CMD_LIMIT = 2,
			PID_INTEGRAL_ACCUMULATOR = 0,
			PID_DERIVATIVE_MEMORY = 1,
			PID_COMMAND_MEMORY = 2,
			PID_NUM_STATUS_VAR = 3,
			PID_INTEGRAL_SATURATION_COUNTER = 0,
			PID_CMD_SATURATION_COUNTER = 1,
			PID_CMD_SATURATION_COUNTER_THRESHOLD = 2,
			PID_NUM_COUNTER = 3,
        };

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC TYPEDEFS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  CONSTRUCTORS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //Empty Constructor
        Pid_s32( void );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  DESTRUCTORS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //Empty destructor
        ~Pid_s32( void );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC REFERENCES
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC OPERATORS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC SETTERS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //Set the fixed point position for all calculations
        bool set_fixed_point_position( int is32_fp );
        //Set PID core gain parameter. Class takes care of converting number from float to fixed point position
        bool set_pid_gain( Index ie_gain_index, float if32_k );
        bool set_pid_gain( float if32_kp, float if32_ki, float if32_kd );
		//Set command limits.
		bool set_command_limit( float if32_cmd_min, float if32_cmd_max );
		//Set the saturation timeout. If command is saturated for too long, PID will go into LOCK mode
		bool set_saturation_timeout( unsigned int iu32_saturation_timeout_cycles );
		bool set_saturation_timeout( unsigned int iu32_saturation_timeout, unsigned int iu32_time_step );


        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC GETTERS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC TESTERS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

		//true = PID is valid and can be run | false = PID is either misconfigured or in error
		bool is_ready( void );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC METHODS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //Try to rearm the PID controller. true=fail, likely means that the PID is misconfigured an has to be reconfigured before it can be rearmed
        bool rearm( void );
        //Convert a floating point 32b to a fixed point 32 bit according to the fixed point position
        int_fast32_t convert_f32_to_s32( float if32_source );
        float convert_s32_to_f32( int_fast32_t is32_source );
        bool convert_f32_to_s32( float if32_source, int_fast32_t &ors32_result );
        bool convert_s32_to_f32( int_fast32_t is32_source, float &orf32_result );


		//Execute a step of PID controller. return true if PID is unable to execute
        bool exe( int_fast32_t is32_ref, int_fast32_t is32_feed, int_fast32_t &ors32_cmd );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC STATIC METHODS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC VARS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

    //Visible to derived classes
    protected:
        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PROTECTED METHODS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PROTECTED VARS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

    //Visible only inside the class
    private:
        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE ENUM
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE TYPEDEFS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE INIT
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //Reset the PID internal status vars
        bool reset_pid_status_vars( void );
        //Initialize class vars
        bool init_class_vars( void );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE TESTER
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

		//Return true if the FP position is invalid
		bool is_invalid_fp( void );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE METHODS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

		//Pid_s32 method to copy the code
        bool dummy( void );

		/*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE STATIC METHODS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

		//Saturate a var to its absolute value.
        template <typename T>
		bool absolute_saturation( T &iort_source, T it_absolute_min, T it_absolute_max );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE VARS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

			//! PID Parameters
			//PID core parameters
		//Fixed Point Position
		uint_fast8_t gu8_fp;
		//PID gain parameters
		int_fast32_t gvs32_k[Index::PID_NUM_GAINS];

			//PID command (output) parameters
		//command limits (absolute)
		int_fast32_t gvs32_cmd[Index::PID_NUM_CMD_LIMIT];
		//command maximum slew rate
		int_fast32_t gs32_command_slew_rate_limit;

			//PID internal status variables
		//Status variables of the PID. Integral, Derivative, Command Slew Rate
		int_fast32_t gvs32_status_var[Index::PID_NUM_STATUS_VAR];
		//Integral saturation counter. Cut off command if integral is saturated for too long.
		uint_fast32_t gvu32_counter[Index::PID_NUM_COUNTER];

			//PID Flags
		//true = PID is locked and forbidden from emitting non zero commands
		bool gu1_lock;

};	//End Class: Pid_s32

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	CONSTRUCTORS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Constructor
//! \n Pid_s32 | void
/***************************************************************************/
// @param
//! @return no return
//! @details
//! \n Empty constructor
/***************************************************************************/

Pid_s32::Pid_s32( void )
{
    DENTER();   //Trace Enter
    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

    //Initialize class vars
    this -> init_class_vars();

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    DRETURN();  //Trace Return
    return;
}   //end constructor: Pid_s32 | void

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	DESTRUCTORS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//!	@brief Destructor
//! \n Pid_s32 | void
/***************************************************************************/
// @param
//! @return no return
//! @details
//! \n Empty destructor
/***************************************************************************/

Pid_s32::~Pid_s32( void )
{
    DENTER();		//Trace Enter
    ///--------------------------------------------------------------------------
    ///	INIT
    ///--------------------------------------------------------------------------

    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    DRETURN();      //Trace Return
    return;         //OK
}   //end destructor: Pid_s32 | void

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PUBLIC REFERENCES
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PUBLIC SETTERS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Public Setter
//! \n set_fixed_point_position | int
/***************************************************************************/
//! @param is32_fp | int | fixed point position
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Set the number of LSB to be used as fixed point decimals
//! \n	FEATURE:
//! \n Automatically refactor already set gains and rearm the PID when FP is changed
//! \n This ensures precision doesn't affect large scale nehaviour of the PID
/***************************************************************************/

bool Pid_s32::set_fixed_point_position( int is32_fp )
{
    DENTER(); //Trace Enter
    ///--------------------------------------------------------------------------
    ///	INIT
    ///--------------------------------------------------------------------------

    //If: safety checks are active and user given input exceed the limits
    if ((Config::SAFETY_CHECK == true) && ((is32_fp < 0) || (is32_fp > Config::PID_FIXED_POINT_LIMIT)))
	{
		//Report error
		this->report_error( "Bad parameter: fixed point position" );
		DRETURN_ARG("Bad parameter: fixed point position"); //Trace Return
		return true;
	}

    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

    //If: the fixed point position has changed
	if (this->gu8_fp != is32_fp)
	{
		//! @todo set_fixed_point_position should automatically refactor already set gains and rearm the PID
		//Save the new fixed point position
		this->gu8_fp = is32_fp;
	}

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    DRETURN(); //Trace Return
    return false;	//OK
}   //end Public Setter: set_fixed_point_position | int

/***************************************************************************/
//! @brief Public Setter
//! \n set_pid_gain | Index, float
/***************************************************************************/
//! @param ie_gain_index | Index | index of PID parameter to set
//! @param if32_k | float |
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Set PID core gain parameter.
//! \n Class takes care of converting number from float to fixed point position
/***************************************************************************/

bool Pid_s32::set_pid_gain( Index ie_gain_index, float if32_k )
{
    DENTER_ARG( "Index: %d | Value %f", ie_gain_index, if32_k ); //Trace Enter
    ///--------------------------------------------------------------------------
    ///	INIT
    ///--------------------------------------------------------------------------

    //If: safety check are active and PID gain index is bad
    if ( (Config::SAFETY_CHECK==true) && ((ie_gain_index != Index::PID_GAIN_KP) && (ie_gain_index != Index::PID_GAIN_KI) &&(ie_gain_index != Index::PID_GAIN_KD)))
	{
		const char *_pu8_error_code = "OOB: Bad gain parameter";
		this->report_error( _pu8_error_code );
		DRETURN_ARG( _pu8_error_code ); //Trace Return
		return true;	//FAIL
	}

    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

    //Convert FP32->S32 based on fixed point position
    int_fast32_t _s32_gain;
    bool _u1_ret = this->convert_f32_to_s32( if32_k, _s32_gain );
	//Assign gain
	this->gvs32_k[ie_gain_index] = _s32_gain;

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    DRETURN_ARG("Success: %d", _u1_ret); //Trace Return
    return _u1_ret;	//Propagate error
}   //end Public Setter: set_pid_gain | Index, float

/***************************************************************************/
//! @brief Public Setter
//! \n set_pid_gain | float, float, float
/***************************************************************************/
//! @param if32_kp | float | proportional gain
//! @param if32_ki | float | integral gain
//! @param if32_kd | float | derivative gain
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Set PID core gain parameter.
//! \n Class takes care of converting number from float to fixed point position
/***************************************************************************/

bool Pid_s32::set_pid_gain( float if32_kp, float if32_ki, float if32_kd )
{
    DENTER_ARG( "KP %f | KI %f | KD %f", if32_kp, if32_ki, if32_kd ); //Trace Enter
    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

    //Initialize return flag
    bool _u1_ret = false;
    //Convert and assign gain
    _u1_ret = _u1_ret | this->convert_f32_to_s32( if32_kp, this->gvs32_k[Index::PID_GAIN_KP] );
    _u1_ret = _u1_ret | this->convert_f32_to_s32( if32_ki, this->gvs32_k[Index::PID_GAIN_KI] );
    _u1_ret = _u1_ret | this->convert_f32_to_s32( if32_kd, this->gvs32_k[Index::PID_GAIN_KD] );

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    DRETURN_ARG("Success: %d", _u1_ret); //Trace Return
    return _u1_ret;	//Propagate error
}   //end Public Setter: set_pid_gain | float, float, float

/***************************************************************************/
//! @brief Public method
//! \n set_command_limit | float, float
/***************************************************************************/
//! @param if32_cmd_min | float | minimum absolute command
//! @param if32_cmd_max | float | maximum absolute command
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Set command limits
//! \n Class takes care of converting number from float to fixed point position
/***************************************************************************/

bool Pid_s32::set_command_limit( float if32_cmd_min, float if32_cmd_max )
{
    DENTER_ARG( "CMD MIN %f | CMD MIN %f", if32_cmd_min, if32_cmd_max ); //Trace Enter
    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

    //Initialize return flag
    bool _u1_ret = false;
    //Convert and assign gain
    _u1_ret = _u1_ret | this->convert_f32_to_s32( if32_cmd_min, this->gvs32_cmd[Index::PID_CMD_LIMIT_MIN] );
    _u1_ret = _u1_ret | this->convert_f32_to_s32( if32_cmd_max, this->gvs32_cmd[Index::PID_CMD_LIMIT_MAX] );

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    DRETURN_ARG("Success: %d", _u1_ret); //Trace Return
    return _u1_ret;	//Propagate error
}   //end Public Setter: set_pid_gain | float, float

/***************************************************************************/
//! @brief Public method
//! \n set_saturation_timeout | unsigned int
/***************************************************************************/
//! @param iu32_saturation_timeout_cycles | unsigned int | number of cycles before lock kicks in. 0=disabled
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Set the saturation timeout. If command is saturated for too long, PID will go into LOCK mode
/***************************************************************************/

inline bool Pid_s32::set_saturation_timeout( unsigned int iu32_saturation_timeout_cycles )
{
    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

	//Set the counter limit
	this->gvu32_counter[Index::PID_CMD_SATURATION_COUNTER_THRESHOLD] = iu32_saturation_timeout_cycles;

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    return false;	//OK
}   //end Public Setter: set_saturation_timeout | unsigned int

/***************************************************************************/
//! @brief Public method
//! \n set_saturation_timeout | unsigned int
/***************************************************************************/
//! @param iu32_saturation_timeout | unsigned int | number time units  before lock kicks in. 0=disabled
//! @param iu32_time_step | unsigned int | time between execution steps
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Set the saturation timeout. If command is saturated for too long, PID will go into LOCK mode
/***************************************************************************/

inline bool Pid_s32::set_saturation_timeout( unsigned int iu32_saturation_timeout, unsigned int iu32_time_step )
{
    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

	uint_fast32_t _u32_timeout = iu32_saturation_timeout /iu32_time_step;
	//Set the counter limit
	this->gvu32_counter[Index::PID_CMD_SATURATION_COUNTER_THRESHOLD] = _u32_timeout;

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    return false;	//OK
}   //end Public Setter: set_saturation_timeout | unsigned int

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PUBLIC GETTERS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**  PUBLIC TESTERS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Public Tester
//! \n is_ready | void
/***************************************************************************/
//! @return bool | true = PID is valid and can be run | false = PID is either misconfigured or in error
/***************************************************************************/

bool Pid_s32::is_ready( void )
{
    DENTER(); //Trace Enter
    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

    //If PID class is in error
	if (this->is_error() == true)
	{
		//PID is not ready
		DRETURN_ARG("ERR: PID class is in error"); //Trace Return
		return false;
	}

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    DRETURN_ARG("Ready..."); //Trace Return
    return true;	//OK
}   //end private method: is_ready | void

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**  PUBLIC METHODS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Private method
//! \n rearm | void
/***************************************************************************/
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Try to rearm the PID controller
//!	\n failure likely means that the PID is misconfigured an has to be reconfigured before it can be rearmed
//!	\n
/***************************************************************************/

bool Pid_s32::rearm( void )
{
    DENTER(); //Trace Enter
    ///--------------------------------------------------------------------------
    ///	INIT
    ///--------------------------------------------------------------------------

	//If class is in error
    if (this->is_error() == true)
	{
		//Clear the error
		this->reset_error();
		DPRINT("Reset Error...\n");
	}

    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    DRETURN(); //Trace Return
    return false;	//OK
}   //end private method: rearm | void

/***************************************************************************/
//! @brief Public method
//! \n convert_s32_to_f32 | int_fast32_t
/***************************************************************************/
//! @param is32_source | fixed point number to be converted
//! @return float | conversion from fixed point to float
/***************************************************************************/

inline float Pid_s32::convert_s32_to_f32( int_fast32_t is32_source )
{
    ///--------------------------------------------------------------------------
    ///	INIT
    ///--------------------------------------------------------------------------

	if ((Config::PEDANTIC_CHECKS == true) && (this->is_invalid_fp() == true))
	{
		return 0.0;
	}

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------

    return float(is32_source) / float(1<<this->gu8_fp);
}   //end Public method: convert_f32_to_s32 | float, int_fast32_t &

/***************************************************************************/
//! @brief Private method
//! \n convert_f32_to_s32 | float, int_fast32_t &
/***************************************************************************/
// @param
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Convert a floating point 32b to a fixed point 32 bit according to the fixed point position
/***************************************************************************/

bool Pid_s32::convert_f32_to_s32( float if32_source, int_fast32_t &ors32_result )
{
    DENTER_ARG("Source f32: %f", if32_source); //Trace Enter
    ///--------------------------------------------------------------------------
    ///	INIT
    ///--------------------------------------------------------------------------

    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

    //Convert at full precision
	if32_source = if32_source *(1<<this->gu8_fp);
	//! @todo Round
	//Cast
	int_fast32_t _s32_result = int(1)*round(if32_source);
	//Write back
	ors32_result = _s32_result;

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    DRETURN_ARG("Result s32: %d", _s32_result); //Trace Return
    return false;	//OK
}   //end private method: convert_f32_to_s32 | float, int_fast32_t &


/***************************************************************************/
//! @brief Public method
//! \n exe | int_fast32_t, int_fast32_t, int_fast32_t &
/***************************************************************************/
//! @param is32_ref | int_fast32_t | reference of the PID
//! @param is32_feed | int_fast32_t | feedback from the system under control
//! @param ors32_cmd | int_fast32_t & | command generated by the PID
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Execute a step of PID controller. return true if PID is unable to execute
/***************************************************************************/

bool Pid_s32::exe( int_fast32_t is32_ref, int_fast32_t is32_feed, int_fast32_t &ors32_cmd )
{
    DENTER_ARG(" Reference: %d %f | Feedback: %d %f", is32_ref, this->convert_s32_to_f32(is32_ref), is32_feed, this->convert_s32_to_f32(is32_feed)); //Trace Enter
    ///--------------------------------------------------------------------------
    ///	INIT
    ///--------------------------------------------------------------------------

	//Command. Initialize to zero in case all gains are inactive
	int_fast32_t _s32_cmd = 0;

    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

		///--------------------------------------------------------------------------
		///	COMPUTE ERROR
		///--------------------------------------------------------------------------
		//	Error = Reference-Feedback

	//Compute 32b error
	int_fast32_t _s32_err32 = is32_ref -is32_feed;
	DPRINT("Err: %d | %f\n", _s32_err32, this->convert_s32_to_f32(_s32_err32));

		///--------------------------------------------------------------------------
		///	COMPUTE PROPORTIONAL
		///--------------------------------------------------------------------------
		//	The proportional component performs the bulk of the quick command generation.
		//	The higher the error, the higher the command has to be to bring the error down
		//	err					: unfiltered 16b error
		//	this -> g_kp		: proportional gain
		//	cmd32				: 32b command accumulator

	//if: gain is active
	if (this->gvs32_k[Index::PID_GAIN_KP] != 0)
	{

		//Compute proportional command. Promote operand to execute operation at 32b resolution
		int_fast32_t _s32_cmd_tmp = _s32_err32 *this->gvs32_k[Index::PID_GAIN_KP];
		//Accumulate command
		_s32_cmd += _s32_cmd_tmp;
		DPRINT("proportional | gain: %d %f | proportional command: %d %f\n", this->gvs32_k[Index::PID_GAIN_KP], this->convert_s32_to_f32(this->gvs32_k[Index::PID_GAIN_KP]), _s32_cmd_tmp, this->convert_s32_to_f32(_s32_cmd_tmp) );
	}

		///--------------------------------------------------------------------------
		///	COMPUTE INTEGRATIVE
		///--------------------------------------------------------------------------
		//	The integral component allows the PID to eventually achieve zero error
		//	Bigger integral means quicker convergence, but also more undershoot and overshoot
		//	Increasing the integral component carry the biggest risk of resonance, like in a mike/speaker feedback
		//	_s32_err32			: unfiltered error
		//	this -> g_ki		: gain of the integral component
		//	this -> g_acc		: 16b accumulator
		//	acc					: temporary 16b accumulator
		//	cmd32				: 32b command accumulator


	//Fetch accumulator
	int_fast32_t _s32_acc = this->gvs32_status_var[Index::PID_INTEGRAL_ACCUMULATOR];
	//if: gain is active
	if (this->gvs32_k[Index::PID_GAIN_KI] != 0)
	{
		//Integrate error inside the accumulator
		_s32_acc += _s32_err32;
		//MAC integral error. Promote operand to execute operation at 32b resolution
		int_fast32_t _s32_cmd_tmp = _s32_acc *this->gvs32_k[Index::PID_GAIN_KI];
		//Accumulate command
		_s32_cmd += _s32_cmd_tmp;
		//DEBUG
		DPRINT("Accumulator: %d %f | Integral Command %d %f\n", _s32_acc, this->convert_s32_to_f32(_s32_acc), _s32_cmd_tmp, this->convert_s32_to_f32(_s32_cmd_tmp) );

	}

		///--------------------------------------------------------------------------
		///	COMPUTE COMMAND
		///--------------------------------------------------------------------------
		//	Command is renormalized as the gains are expressed in fixed point

	//Apply Fixed Point renormalization
	_s32_cmd = SSHR_RTO( _s32_cmd, this->gu8_fp );
	//Saturate command to its limit and detect saturation
	bool _u1_cmd_saturation = this->absolute_saturation( _s32_cmd, this->gvs32_cmd[Index::PID_CMD_LIMIT_MIN], this->gvs32_cmd[Index::PID_CMD_LIMIT_MAX]);
	//if saturation failed
	if ((Config::PEDANTIC_CHECKS == true) && (this->is_error() == true))
	{
		//! @todo handle command saturation fail
		DPRINT("ERR: failed to execute absolute saturation\n");
	}

		///--------------------------------------------------------------------------
		///	SATURATION DETECTION
		///--------------------------------------------------------------------------
		//	This feature is meant to detect when command is saturated for too long.
		//	This means that the PID is unable to keep up with the system and the PID is unlocked
		//	Es. A motor as encoder connected in reverse. The PID can never bring error to zero, so cut off to prevent damage.
		//	Es. Achieve a given speed against too great a resistive force. Command cannot be achieved with this level of power and PID cut off.


	//If feature is disabled OR if command is NOT saturated OR if accumulator would decrease
	if
	(
		(this->gvu32_counter[Index::PID_CMD_SATURATION_COUNTER_THRESHOLD] == 0) ||
		(_u1_cmd_saturation == false)
	)
	{
		//Clear the command counter. Short saturations are permitted as the PID can still somehow keep up
		this->gvu32_counter[Index::PID_CMD_SATURATION_COUNTER] = 0;
	}
	//If saturation detected or if slew rate limit has been exceeded
	else
	{
		//if: PID has still cycles left to try to bring the command below saturation
		if (this->gvu32_counter[Index::PID_CMD_SATURATION_COUNTER] < this->gvu32_counter[Index::PID_CMD_SATURATION_COUNTER_THRESHOLD] )
		{
			//One fewer cycle left for the PID to get its act together
			this->gvu32_counter[Index::PID_CMD_SATURATION_COUNTER]++;
			DPRINT("Command saturation detected %d cycles.\n", this->gvu32_counter[Index::PID_CMD_SATURATION_COUNTER]);
		}
		//if: PID has tried enough times and still could not bring command below saturation
		else
		{
			//
			this->gu1_lock = true;
			DPRINT("PID LOCK: Command has been saturated for %d cycles\n", this->gvu32_counter[Index::PID_CMD_SATURATION_COUNTER]);
		}
	}

		///--------------------------------------------------------------------------
		///	UPDATE STATUS VARS
		///--------------------------------------------------------------------------

	//if: PID is unlocked
	if (this->gu1_lock == false)
	{
		//if: command is NOT saturated or the accumulator would decrease in absolute value
		if ((_u1_cmd_saturation == false) || (AT_ABS(_s32_acc) < AT_ABS(this->gvs32_status_var[Index::PID_INTEGRAL_ACCUMULATOR])) )
		{
			//Update integral accumulator
			this->gvs32_status_var[Index::PID_INTEGRAL_ACCUMULATOR] = _s32_acc;
			DPRINT("Update integral accumulator: %d %f -> %d %f\n", _s32_acc, this->convert_s32_to_f32(_s32_acc), this->gvs32_status_var[Index::PID_INTEGRAL_ACCUMULATOR], this->convert_s32_to_f32(this->gvs32_status_var[Index::PID_INTEGRAL_ACCUMULATOR]));
		}
		//if: command is saturated, and the accumulator would increase in value
		else
		{
			//Do nothing. Increasing the accumulator at this point, would only make the recovery harder
			DPRINT("Update of accumulator not authorized: : %d %f -> %d %f\n", _s32_acc, this->convert_s32_to_f32(_s32_acc), this->gvs32_status_var[Index::PID_INTEGRAL_ACCUMULATOR], this->convert_s32_to_f32(this->gvs32_status_var[Index::PID_INTEGRAL_ACCUMULATOR]));
		}
	}
	//if: PID is locked
	else
	{
		//Force command to zero
		_s32_cmd = 0;
		DPRINT("LOCK: force command to zero\n");
	}

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    ors32_cmd = _s32_cmd;
    DRETURN_ARG("Command %d %f", _s32_cmd,this->convert_s32_to_f32(_s32_cmd)); //Trace Return
    return false;	//OK
}   //end Public method: exe | int_fast32_t, int_fast32_t, int_fast32_t &

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PRIVATE INIT
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Private init
//! \n reset_pid_status_vars | void
/***************************************************************************/
//! @return no return
//! @details
//! \n Reset the PID internal status vars
/***************************************************************************/

bool Pid_s32::reset_pid_status_vars( void )
{
    DENTER();		//Trace Enter
    ///--------------------------------------------------------------------------
    ///	INIT
    ///--------------------------------------------------------------------------

    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

	//Reset Integral
	this->gvs32_status_var[Index::PID_INTEGRAL_ACCUMULATOR] = 0;

	//If command is pegged to MAX for this number of cycles, PID is cut off. 0= featuredisabled
	this->gvu32_counter[Index::PID_CMD_SATURATION_COUNTER_THRESHOLD] = 0;

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    DRETURN();      //Trace Return
    return false;   //OK
}   //end init: reset_pid_status_vars | void

/***************************************************************************/
//! @brief Private init
//! \n init_class_vars | void
/***************************************************************************/
// @param
//! @return no return
//! @details
//! \n Initialize class vars
/***************************************************************************/

bool Pid_s32::init_class_vars( void )
{
    DENTER();		//Trace Enter
    ///--------------------------------------------------------------------------
    ///	INIT
    ///--------------------------------------------------------------------------

    //Reset PID status vars
    this->reset_pid_status_vars();
    //Clear warnings and errors
    this->reset_warning();
    this->reset_error();

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    DRETURN();      //Trace Return
    return false;   //OK
}   //end init: init_class_vars | void

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PRIVATE TESTER
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Private tester
//! \n is_invalid_fp | void
/***************************************************************************/
//! @return bool | false = valid FP | true = invalid FP |
//! @details
//! \n Return true if the FP position is invalid
/***************************************************************************/

inline bool Pid_s32::is_invalid_fp( void )
{
    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------

    return (gu8_fp >= Config::PID_FIXED_POINT_LIMIT );
}   //end private tester: is_invalid_fp | void

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PRIVATE METHODS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Private method
//! \n dummy | void
/***************************************************************************/
// @param
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Method
/***************************************************************************/

bool Pid_s32::dummy( void )
{
    DENTER(); //Trace Enter
    ///--------------------------------------------------------------------------
    ///	INIT
    ///--------------------------------------------------------------------------

    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------
    DRETURN(); //Trace Return
    return false;	//OK
}   //end private method:

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PRIVATE STATIC METHODS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Private static method
//! \n absolute_saturation | T &, T, T
/***************************************************************************/
//! @param iort_source | T & | reference to number to be saturated
//! @param it_absolute_min | T | absolute minimum. all non zero value will be increased to this value with correct sign
//! @param it_absolute_max | T | absolute maximum. all value above maximum will be clipped to this value with correct sign
//! @return bool | false = below maximum | true = above maximum |
//! @details
//! \n Saturate a var to its absolute value.
/***************************************************************************/

template <typename T>
inline bool Pid_s32::absolute_saturation( T &iort_source, T it_absolute_min, T it_absolute_max )
{
    ///--------------------------------------------------------------------------
    ///	INIT
    ///--------------------------------------------------------------------------

    //Temp working value
	T _t_value = iort_source;
	//If inputs are not positive
	if ((Config::PEDANTIC_CHECKS == true) && ((it_absolute_min < 0) || (it_absolute_max < 0)) )
	{
		//zero the input
		iort_source = 0;
		//ERROR
		this->report_error("ERR: cmd limits min and/or max are not positive");
		return true;
	}
	//If maximum not above minimum
	if ((Config::PEDANTIC_CHECKS == true) && (it_absolute_min >= it_absolute_max) )
	{
		//zero the input
		iort_source = 0;
		//ERROR
		this->report_error("ERR: cmd limits max is not above min");
		return true;
	}

    ///--------------------------------------------------------------------------
    ///	BODY
    ///--------------------------------------------------------------------------

    //Temp return
    bool _u1_ret = false;
    //if: value is exactly zero
	if (iort_source == 0)
	{
		//do nothing
		return false;
	}
	//if: below min
	else if (std::abs(_t_value) < it_absolute_min)
	{
		//Increase to positive min
		_t_value = it_absolute_min;
	}
	//if: above max
	else if (std::abs(_t_value) > it_absolute_max)
	{
		//Increase to positive max
		_t_value = it_absolute_min;
		//Saturation detected
		_u1_ret = true;
	}
	//if: in range
	else
	{
		//Do nothing
		return false;
	}

	//sign correction
	if (_t_value < 0)
	{
		//Change sign
		_t_value = -_t_value;
	}

    ///--------------------------------------------------------------------------
    ///	RETURN
    ///--------------------------------------------------------------------------

    //Write back to the reference the corrected value
    iort_source = _t_value;
    return _u1_ret;
}   //end private static method: absolute_saturation | T &, T, T


/**********************************************************************************
**	NAMESPACE
**********************************************************************************/

} //End Namespace: User

#else
    #warning "Multiple inclusion of hader file CLASS_PID_S32_HPP_"
#endif
